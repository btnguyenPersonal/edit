diff --git a/.clang-format b/.clang-format
index d7bfe06..245e939 100644
--- a/.clang-format
+++ b/.clang-format
@@ -1,18 +1,109 @@
-BasedOnStyle: LLVM
-IndentWidth: 4
+---
 AccessModifierOffset: -4
-ColumnLimit: 180
-PointerAlignment: Left
-BreakBeforeBinaryOperators: None
-BinPackParameters: true
+AlignAfterOpenBracket: Align
+AlignConsecutiveAssignments: false
+AlignConsecutiveDeclarations: false
+AlignEscapedNewlines: Left
+AlignOperands: true
+AlignTrailingComments: false
+AllowAllParametersOfDeclarationOnNextLine: false
+AllowShortBlocksOnASingleLine: false
+AllowShortCaseLabelsOnASingleLine: false
+AllowShortFunctionsOnASingleLine: None
+AllowShortIfStatementsOnASingleLine: false
+AllowShortLoopsOnASingleLine: false
+AlwaysBreakAfterDefinitionReturnType: None
+AlwaysBreakAfterReturnType: None
+AlwaysBreakBeforeMultilineStrings: false
+AlwaysBreakTemplateDeclarations: false
 BinPackArguments: true
-PenaltyBreakBeforeFirstCallParameter: 1000
-PenaltyBreakAssignment: 1000
-PenaltyBreakString: 1000
-PenaltyBreakFirstLessLess: 1000
+BinPackParameters: true
 BraceWrapping:
-  AfterEnum: true
-  AfterStruct: true
-  AfterClass: true
+  AfterClass: false
+  AfterControlStatement: false
+  AfterEnum: false
   AfterFunction: true
-  AfterControlStatement: Always
\ No newline at end of file
+  AfterNamespace: true
+  AfterObjCDeclaration: false
+  AfterStruct: false
+  AfterUnion: false
+  AfterExternBlock: false
+  BeforeCatch: false
+  BeforeElse: false
+  IndentBraces: false
+  SplitEmptyFunction: true
+  SplitEmptyRecord: true
+  SplitEmptyNamespace: true
+BreakBeforeBinaryOperators: None
+BreakBeforeBraces: Custom
+BreakBeforeInheritanceComma: false
+BreakBeforeTernaryOperators: false
+BreakConstructorInitializersBeforeComma: false
+BreakConstructorInitializers: BeforeComma
+BreakAfterJavaFieldAnnotations: false
+BreakStringLiterals: false
+ColumnLimit: 80
+CommentPragmas: '^ IWYU pragma:'
+CompactNamespaces: false
+ConstructorInitializerAllOnOneLineOrOnePerLine: false
+ConstructorInitializerIndentWidth: 8
+ContinuationIndentWidth: 8
+Cpp11BracedListStyle: false
+DerivePointerAlignment: false
+DisableFormat: false
+ExperimentalAutoDetectBinPacking: false
+FixNamespaceComments: false
+
+IncludeBlocks: Preserve
+IncludeCategories:
+  - Regex: '.*'
+    Priority: 1
+IncludeIsMainRegex: '(Test)?$'
+IndentCaseLabels: false
+IndentGotoLabels: false
+IndentPPDirectives: None
+IndentWidth: 8
+IndentWrappedFunctionNames: false
+JavaScriptQuotes: Leave
+JavaScriptWrapImports: true
+KeepEmptyLinesAtTheStartOfBlocks: false
+MacroBlockBegin: ''
+MacroBlockEnd: ''
+MaxEmptyLinesToKeep: 1
+NamespaceIndentation: None
+ObjCBinPackProtocolList: Auto
+ObjCBlockIndentWidth: 8
+ObjCSpaceAfterProperty: true
+ObjCSpaceBeforeProtocolList: true
+
+# Taken from git's rules
+PenaltyBreakAssignment: 10
+PenaltyBreakBeforeFirstCallParameter: 30
+PenaltyBreakComment: 10
+PenaltyBreakFirstLessLess: 0
+PenaltyBreakString: 10
+PenaltyExcessCharacter: 100
+PenaltyReturnTypeOnItsOwnLine: 60
+
+PointerAlignment: Right
+ReflowComments: false
+SortIncludes: false
+SortUsingDeclarations: false
+SpaceAfterCStyleCast: false
+SpaceAfterTemplateKeyword: true
+SpaceBeforeAssignmentOperators: true
+SpaceBeforeCtorInitializerColon: true
+SpaceBeforeInheritanceColon: true
+SpaceBeforeParens: ControlStatementsExceptForEachMacros
+SpaceBeforeRangeBasedForLoopColon: true
+SpaceInEmptyParentheses: false
+SpacesBeforeTrailingComments: 1
+SpacesInAngles: false
+SpacesInContainerLiterals: false
+SpacesInCStyleCastParentheses: false
+SpacesInParentheses: false
+SpacesInSquareBrackets: false
+Standard: Cpp03
+TabWidth: 8
+UseTab: Always
+...
diff --git a/README.md b/README.md
index cba1f8d..8cb7e21 100644
--- a/README.md
+++ b/README.md
@@ -326,6 +326,7 @@ wordwrap off
 showmode on
 autosave on
 indent_size = 4
+indent_style = space
 ```
 
 # faq
diff --git a/src/keybinds/sendVisualKeys.cpp b/src/keybinds/sendVisualKeys.cpp
index dfef0cc..c808aa8 100644
--- a/src/keybinds/sendVisualKeys.cpp
+++ b/src/keybinds/sendVisualKeys.cpp
@@ -163,9 +163,9 @@ void surroundParagraph(State* state, bool includeLastLine) {
 }
 
 bool isValidMoveableChunk(State* state, Bounds bounds) {
-    int32_t start = getNumLeadingSpaces(state->data[bounds.minR]);
+    int32_t start = getNumLeadingIndentCharacters(state, state->data[bounds.minR]);
     for (uint32_t i = bounds.minR + 1; i <= bounds.maxR; i++) {
-        if (getNumLeadingSpaces(state->data[i]) < start && state->data[i] != "") {
+        if (getNumLeadingIndentCharacters(state, state->data[i]) < start && state->data[i] != "") {
             return false;
         }
     }
diff --git a/src/util/comment.cpp b/src/util/comment.cpp
index 69a0d1f..db5d115 100644
--- a/src/util/comment.cpp
+++ b/src/util/comment.cpp
@@ -46,7 +46,7 @@ void toggleComment(State* state) { toggleCommentHelper(state, state->row, -1); }
 void toggleCommentHelper(State* state, uint32_t row, int32_t commentIndex) {
     std::string line = state->data[row];
     if (commentIndex == -1) {
-        int32_t i = getNumLeadingSpaces(line);
+        int32_t i = getNumLeadingIndentCharacters(state, line);
         if (isCommentWithSpace(state, line)) {
             state->data[row] = line.substr(0, i) + line.substr(i + state->commentSymbol.length() + 1);
             return;
@@ -56,7 +56,7 @@ void toggleCommentHelper(State* state, uint32_t row, int32_t commentIndex) {
         }
     }
     if (line.length() != 0) {
-        int32_t spaces = commentIndex != -1 ? commentIndex : getNumLeadingSpaces(line);
+        int32_t spaces = commentIndex != -1 ? commentIndex : getNumLeadingIndentCharacters(state, line);
         state->data[row] = line.substr(0, spaces) + state->commentSymbol + ' ' + line.substr(spaces);
     }
 }
@@ -83,7 +83,7 @@ void toggleCommentLines(State* state, Bounds bounds) {
     if (foundNonComment) {
         minIndentLevel = INT_MAX;
         for (size_t i = bounds.minR; i <= bounds.maxR; i++) {
-            int32_t indent = getNumLeadingSpaces(state->data[i]);
+            int32_t indent = getNumLeadingIndentCharacters(state, state->data[i]);
             if (indent < minIndentLevel && state->data[i] != "") {
                 minIndentLevel = indent;
             }
diff --git a/src/util/helper.cpp b/src/util/helper.cpp
index b5c729c..18f49da 100644
--- a/src/util/helper.cpp
+++ b/src/util/helper.cpp
@@ -552,14 +552,34 @@ void trimTrailingWhitespace(State* state) {
     }
 }
 
-// TODO also work with tabs
+bool isWhitespace(char c) {
+    return std::isspace(c) || c == '\t';
+}
+
 void rtrim(std::string& s) {
-    s.erase(std::find_if(s.rbegin(), s.rend(), [](unsigned char ch) { return !std::isspace(ch); }).base(), s.end());
+    s.erase(
+        std::find_if(
+            s.rbegin(),
+            s.rend(),
+            [](unsigned char ch) {
+                return !isWhitespace(ch);
+            }
+        ).base(),
+        s.end()
+    );
 }
 
-// TODO also work with tabs
 void ltrim(std::string& s) {
-    s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](unsigned char ch) { return !std::isspace(ch); }));
+    s.erase(
+        s.begin(),
+        std::find_if(
+            s.begin(),
+            s.end(),
+            [](unsigned char ch) {
+                return !isWhitespace(ch);
+            }
+        )
+    );
 }
 
 std::string getCurrentWord(State* state) {
@@ -574,6 +594,7 @@ std::string getCurrentWord(State* state) {
     return currentWord;
 }
 
+// TODO clean up gpt garbage
 std::string autocomplete(State* state, const std::string& query) {
     if (query == "") {
         return "";
@@ -1423,18 +1444,30 @@ uint32_t getIndentSize(State* state) {
             return 2;
         }
     }
+    if (state->options.indentStyle == "tab") {
+        return 1;
+    }
     return state->options.indent;
 }
 
+char getIndentCharacter(State* state) {
+    if (state->options.indentStyle == "tab") {
+        return '\t';
+    } else if (state->options.indentStyle == "space") {
+        return ' ';
+    }
+    return 'E';
+}
+
 void indent(State* state) {
     for (uint32_t i = 0; i < getIndentSize(state); i++) {
-        state->data[state->row] = " " + state->data[state->row];
+        state->data[state->row] = getIndentCharacter(state) + state->data[state->row];
     }
 }
 
 void deindent(State* state) {
     for (uint32_t i = 0; i < getIndentSize(state); i++) {
-        if (state->data[state->row].substr(0, 1) == " ") {
+        if (state->data[state->row].substr(0, 1) == std::string("") + getIndentCharacter(state)) {
             state->data[state->row] = state->data[state->row].substr(1);
         }
     }
@@ -1443,7 +1476,7 @@ void deindent(State* state) {
 int32_t getIndexFirstNonSpace(State* state) {
     int32_t i;
     for (i = 0; i < (int32_t)state->data[state->row].length(); i++) {
-        if (state->data[state->row][i] != ' ') {
+        if (state->data[state->row][i] != getIndentCharacter(state)) {
             return i;
         }
     }
diff --git a/src/util/helper.h b/src/util/helper.h
index 0d3d952..e4fc164 100644
--- a/src/util/helper.h
+++ b/src/util/helper.h
@@ -7,6 +7,7 @@
 #include <string>
 #include <vector>
 
+char getIndentCharacter(State* state);
 uint32_t getIndentSize(State* state);
 std::string getRelativeToLastAndRoute(State* state);
 std::string getRelativeToCurrent(State* state, std::string p);
diff --git a/src/util/indent.cpp b/src/util/indent.cpp
index af45940..b288eaf 100644
--- a/src/util/indent.cpp
+++ b/src/util/indent.cpp
@@ -11,16 +11,16 @@ bool autoIndentDisabledFileType(std::string filename) {
     return false;
 }
 
-int32_t getNumLeadingSpaces(std::string s) {
-    int32_t numSpaces = 0;
+int32_t getNumLeadingIndentCharacters(State* state, std::string s) {
+    int32_t num = 0;
     for (uint32_t i = 0; i < s.length(); i++) {
-        if (s[i] == ' ') {
-            numSpaces++;
+        if (s[i] == getIndentCharacter(state)) {
+            num++;
         } else {
             break;
         }
     }
-    return numSpaces;
+    return num;
 }
 
 std::string getPrevLine(State* state, uint32_t row) {
@@ -47,6 +47,9 @@ bool hasHTML(std::string line, std::string extension) {
         if (trimmed.empty()) {
             return false;
         }
+        if (safeSubstring(trimmed, 0, std::string("#include ").length()) == "#include ") {
+            return false;
+        }
         return trimmed.front() == '<' || trimmed.back() == '>' || trimmed.front() == '>' || trimmed.back() == '<';
     }
     return false;
@@ -63,7 +66,7 @@ int32_t getIndentLevel(State* state, uint32_t row) {
     prevLine = trimComment(state, prevLine);
     std::string currLine = state->data[row];
     ltrim(currLine);
-    int32_t indentLevel = getNumLeadingSpaces(prevLine);
+    int32_t indentLevel = getNumLeadingIndentCharacters(state, prevLine);
     uint32_t indentSize = getIndentSize(state);
 
     if (hasHTML(prevLine, getExtension(state->filename))) {
@@ -159,7 +162,7 @@ void indentLine(State* state, uint32_t row) {
     if (state->data[row].length() != 0) {
         int32_t indentLevel = getIndentLevel(state, row);
         for (int32_t i = 0; i < indentLevel; i++) {
-            state->data[row] = ' ' + state->data[row];
+            state->data[row] = getIndentCharacter(state) + state->data[row];
         }
     }
 }
@@ -169,7 +172,7 @@ void indentLine(State* state) {
     if (state->data[state->row].length() != 0) {
         int32_t indentLevel = getIndentLevel(state, state->row);
         for (int32_t i = 0; i < indentLevel; i++) {
-            state->data[state->row] = ' ' + state->data[state->row];
+            state->data[state->row] = getIndentCharacter(state) + state->data[state->row];
         }
     }
 }
@@ -182,13 +185,13 @@ void indentRange(State* state) {
             break;
         }
     }
-    int32_t indentDifference = getIndentLevel(state, state->row) - getNumLeadingSpaces(state->data[firstNonEmptyRow]);
+    int32_t indentDifference = getIndentLevel(state, state->row) - getNumLeadingIndentCharacters(state, state->data[firstNonEmptyRow]);
     if (indentDifference > 0) {
         for (int32_t i = state->row; i <= (int32_t)state->visual.row; i++) {
             // TODO turn below into helper function that takes into account the indentStyle
             if (state->data[i] != "") {
                 for (int32_t j = 0; j < indentDifference; j++) {
-                    state->data[i] = ' ' + state->data[i];
+                    state->data[i] = getIndentCharacter(state) + state->data[i];
                 }
             }
         }
@@ -196,7 +199,7 @@ void indentRange(State* state) {
         for (int32_t i = state->row; i <= (int32_t)state->visual.row; i++) {
             if (state->data[i] != "") {
                 for (int32_t j = 0; j < -1 * indentDifference; j++) {
-                    if (state->data[i].length() > 0 && state->data[i][0] == ' ') {
+                    if (state->data[i].length() > 0 && state->data[i][0] == getIndentCharacter(state)) {
                         state->data[i] = safeSubstring(state->data[i], 1);
                     }
                 }
diff --git a/src/util/indent.h b/src/util/indent.h
index be82932..c994953 100644
--- a/src/util/indent.h
+++ b/src/util/indent.h
@@ -5,7 +5,7 @@
 #include <vector>
 
 bool autoIndentDisabledFileType(std::string filename);
-int32_t getNumLeadingSpaces(std::string s);
+int32_t getNumLeadingIndentCharacters(State* state, std::string s);
 std::string getPrevLine(State* state, uint32_t row);
 int32_t getIndentLevel(State* state, uint32_t row);
 void indentLine(State* state, uint32_t row);
diff --git a/src/util/render.cpp b/src/util/render.cpp
index 04e8909..652ba1d 100644
--- a/src/util/render.cpp
+++ b/src/util/render.cpp
@@ -316,26 +316,12 @@ bool isMergeConflict(const std::string& str) {
     return false;
 }
 
-void printChar(State* state, int32_t row, int32_t col, char c, int32_t color) {
-    if (' ' <= c && c <= '~') {
-        mvaddch_color(row, col + getLineNumberOffset(state), c, color);
-    } else if (c == '\t') {
-        for (uint32_t i = 0; i < getIndentSize(state); i++) {
-            mvaddch_color(row, col + getLineNumberOffset(state), ' ', color);
-        }
-    } else if (' ' <= unctrl(c) && unctrl(c) <= '~') {
-        mvaddch_color(row, col + getLineNumberOffset(state), unctrl(c), invertColor(MAGENTA));
-    } else {
-        mvaddch_color(row, col + getLineNumberOffset(state), ' ', invertColor(MAGENTA));
-    }
-}
-
 void printChar(State* state, int& row, int& col, char c, int32_t color, bool advance) {
     if (' ' <= c && c <= '~') {
         mvaddch_color(row, col + getLineNumberOffset(state), c, color);
     } else if (c == '\t') {
-        for (uint32_t i = 0; i < getIndentSize(state); i++) {
-            mvaddch_color(row, col + getLineNumberOffset(state), ' ', color);
+        for (uint32_t i = 0; i < state->options.indent; i++) {
+            mvaddch_color(row, col + getLineNumberOffset(state), '.', color == WHITE ? GREY : color);
             advancePosition(state, row, col);
         }
         return;
@@ -349,6 +335,10 @@ void printChar(State* state, int& row, int& col, char c, int32_t color, bool adv
     }
 }
 
+void printChar(State* state, int32_t row, int32_t col, char c, int32_t color) {
+    printChar(state, row, col, c, color, false);
+}
+
 bool isRowColInVisual(State* state, uint32_t i, uint32_t j) {
     if (state->mode == VISUAL) {
         uint32_t minR;
